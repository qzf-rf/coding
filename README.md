# **学代码，从最简单的开始**

## **代码规范**

### **1. 代码命名规范**

|类型|示例|
|:--:|:--------:|
|类名|ThisIsClass|
|变量名|thisIsValue|
|函数名|thisIsValue|
|常量名|THIS_IS_CONSTANT|

<br>

### **2. 代码书写规范**

#### 1. 合并判断条件，减少 if 语句

```
if (sortType == SortType.descend)
```
优化为
```
if (num > data[i] && sortType == SortType.descend)
```

<br>

#### 2. 简化注释，尽量通过代码阐述

> 若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述
>
> **去掉下面复杂的注释，只需要创建一个与注释所言同一事物的函数即可**
>
> ```
> // check to see if the employee is eligible for full benefits
> if ((employee.flags & HOURLY_FLAG) && (employee.age > 65))
> ```
> 应替换为
> ```
> if (employee.isEligibleForFullBenefits())
> ```

<br>

#### 3. **Java 5** 中引入主要用于**数组**的**增强型 for 循环**

```
for (int num : nums)
```
等价于
```
for (int i = 0; i < nums.length; i++) {
    nums[i] ...
}
```

<br>

## **总结思路**

#### 1. 谨慎处理边界问题（***空数组*** 等）

#### 2. 转换思路，以**不变**应万变，将复杂简单化
- **题目 283 移动零**：后移 0 → 前移非 0
- **题目 566 重塑矩阵**：index 表示重构矩阵前后的第 index 个元素
- **题目 485 最大连续 1 的个数**：连续 1 → 遇 0 则重新计数

#### 3. **类比**经典算法
- **题目 03 数组中重复的数字**：n 个元素，取值范围为 0~n-1 → **类 Hash** 寻找元素冲突
- **题目 04 二维数组中的查找**：行和列均递增 → **类二分法**缩小查找范围

#### 4. 二叉树的遍历
- **后序**遍历
  - **题目 104 二叉树的最大深度**
  - **题目 110 平衡二叉树**
 
#### 5. 动态规划的状态压缩
- O(n) → O(1)
  - **题目 70 爬楼梯**：存储**第 i - 2 个**和**第 i - 1 个**元素
- O(n<sup>2</sup>) → O(n)
  - **题目 62 不同路径**：存储**第 i - 1 行**元素，更新**第 j - 1 个**元素

#### 6. 递归问题的复杂度
- 递归问题的时间复杂度 = ***递归总次数 * 每次递归中的操作次数***
- 递归问题的空间复杂度 = ***递归深度 * 每次递归的辅助空间***

#### 7. DFS 算法 与 BFS 算法

- **DFS 算法**：深度优先
  - 利用 ***递归***，遍历**决策树**
  - 全排列 / 可行路径
  - 时间复杂度大
- **BFS 算法**：广度优先
  - 利用 ***队列***，**图**的起点到终点
  - **最短**路径
  - 空间复杂度大

<br>

## **数据结构与算法之美**

### **1. 数组**

> #### **题目 1：大小固定的有序数组，支持动态增删改**

- **错误 1**：插入函数搜索插入位置时 index 初值为 -1，***未考虑空数组的情况，导致数组越界***


```
// 考虑空数组，因此 index 设为 0
if (count == 0) {
    index = 0;
}
```

- **错误 2**：降序数组只有元素 7 时，插入 4 的index值为 0，反而插入到了 7 前面，***未考虑数组元素比较结束，插入数组末尾的情况***
```
// 考虑插入数组末尾的情况
if (i == count) {
    index = count;
}
```
***查找成功后没有 break 循环***，导致此判断条件失效

- **总结**：**未考虑插入首位和末位的特殊情况（即*边界*）**

<br>

> #### **题目 2：支持动态扩容的无序数组，按索引增删改查**

1. 无参构造函数**调用**有参构造函数
2. 数组已满则扩容，不足1/4则缩容为1/2，扩容和缩容调用同一函数

<br>

> #### **题目 3：两个有序数组合并为一个有序数组**

- **错误**：数组中有 count 个元素，但最后一个元素的位置是 count-1

<br>

## **剑指Offer**

> #### **题目 03：数组中重复的数字**
> 在一个长度为 n 的数组 nums 里的所有数字都在 0~n-1 的范围内

- **思路1（×）**：HashSet的add方法，元素重复则返回false

- **思路2（√）**：将值为 i 的元素调整到第 i 个位置上进行求解（***类Hash***）
> 时间复杂度 O(n)，空间复杂度 O(1)

- **注意事项**：
  - 某处缺少返回值
  - 先初始化类，才能在main函数中调用

<br>

> #### **题目 04：二维数组中的查找**
> 行和列均递增

|a[i][1]|a[i][2]|a[i][3]|a[i][4]|
|:-:|:-:|:-:|:-:|
|1|2|8|9|
|2|4|9|12|
|4|7|10|13|
|6|8|11|15|
 
- **思路**：选取数组中右上角的数字，缩小查找区间（***类似二分法取中值***）
1. `if` 该数字=要查找的数字，查找过程结束
2. `else if` 该数字>要查找的数字，剔除这个数字所在的列
3. `else if` 该数字<要查找的数字，剔除这个数字所在的行

- **注意事项**：
  - **空数组**求长度越界
  - 判断空数组的条件写在一起
```
if (matrix == null || matrix.length == 0 || matrix[0].length == 0)
```

> 时间复杂度 O(M + N)，空间复杂度 O(1)

<br>

## **LeetCode**

### **1. 数组与矩阵**

> #### **题目 283：移动零**
> 将数组 nums 中的 0 移动至数组末尾

- **思路**：遍历数组，跳过 0 元素，即前移非 0 元素，最后根据 index 位置在末尾补 0（***移动 0 至末尾 → 移动非 0 至前面***）
> 时间复杂度 O(n)，空间复杂度 O(1)

<br>

> #### **题目 566：重塑矩阵**
> 将 m×n 的矩阵 nums 重构为 r×c 的矩阵 reshapedNums

- **思路**：重构过程中**行遍历**的元素位置不变，将 index 设为原数组 nums 行遍历的第 index 个元素（index < m×n），则重构后其依然为第 index 个元素
1. 2×2 → 1×4：reshapedNums[i][j] = nums[index / 2][index % 2]
2. 1×6 → 2×3：reshapedNums[i][j] = nums[index / 6][index % 1]
3. m×n → r×c：reshapedNums[i][j] = nums[index / n][index % n]

> 时间复杂度 O(r * c)，空间复杂度 O(r * c)

<br>

> #### **题目 485：最大连续 1 的个数**
> 数组中只包含 0 和 1

- **思路**：遍历数组，若元素为 1 则计数加 1，若元素为 0 则重新计数，**记录计数的最大值**

- **注意事项**：`count = num == 1 ? count + 1 : 0` 中运算符优先级顺序为 `+` > `==` > `?:` > `=`，因此**不需加括号**

> 时间复杂度 O(n)，空间复杂度 O(1)

<br>

### **2. 二叉树**

> #### **题目 104：二叉树的最大深度**
> 根节点、左子树、右子树

- **思路**：**后序遍历**二叉树，***取左右子树最大深度 + 1***

- **注意事项**：`max` 函数在 `Math` 库中

> 时间复杂度 O(n)，空间复杂度 O(depth)<br>
> n 为节点数，depth 为树的深度

<br>

> #### **题目 110：平衡二叉树**
> |左子树高度 - 右子树高度| ≤ 1

- **思路**：**后序遍历**二叉树，写树的遍历函数，***取每个节点左右子树最大深度绝对值，判断是否平衡***

- **注意事项**：
  - `abs` 函数在 `Math` 库中
  - 添加类成员变量作为**flag**

> 时间复杂度 O(n)，空间复杂度 O(depth)<br>
> n 为节点数，depth 为树的深度

<br>

### **3. 动态规划**

> #### **题目 70：爬楼梯**
> 每次可以爬 1 或 2 阶，有几种方法爬到 n 阶

- **思路**：DP table + 状态压缩
  - 最后一步爬 2 阶或 1 阶：dp[i] = dp[i - 2] + dp[i - 1]
  - **状态压缩**：**只需 i - 2 阶和 i - 1 阶**
  - **状态转移方程**：cur = pre2 + pre1

- **注意事项**：一开始思路错误
  - *爬 i - 2 个楼梯再爬 1 阶 = 爬 i - 1 个楼梯*，**计算重复**
  - 不用再加 1 或 2，因为一种**方法**指的是整个爬楼的过程，不是**每一步**

> 时间复杂度 O(n)，空间复杂度 O(1)<br>
> ***相似题目***：**题目 509 斐波那契数**

<br>

> #### **题目 62：不同路径**
> m×n 的矩阵，从左上角到右下角，向右或向下移动一步，求不同的路径数

- **思路**：DP table + 状态压缩
  - 最后一步向右或向下：dp[m][n] = dp[m - 1][n] + dp[m][n - 1]
  - **状态压缩**：从第 2 行开始逐行计算，**只需上一行和前一个元素**，可将二维数组压缩为一维数组
  - **状态转移方程**：dp[j] = dp[j] + dp[j - 1]

- **注意事项**：`Arrays.fill(dp, 1)` 填充数组为 1

> 时间复杂度 O(n)，空间复杂度 O(n)

<br>

> #### **题目 322：零钱兑换**
> k 种面值的硬币：c1, c2, ..., ck，以最少的硬币数凑出总金额 amount

- **思路**：DP table
  - **状态转移方程**：min|以最少的硬币数凑出 i - coin + 1 枚面值 coin 的硬币|，dp[i] = min(1 + dp[i - coin] | coin ∈ coins) 

- **注意事项**：dp 数组初始化为 amount + 1，**最多**用 amount + 1 枚硬币凑出

> 时间复杂度 O(kn)，空间复杂度 O(n)

<br>

> #### **题目 198：打家劫舍**
> 抢劫一排住户，但是不能抢邻近的住户，求最大抢劫量

- **思路**：DP table + 状态压缩
  - **状态转移方程**：max|抢到第 i - 2 户的最高金额 + 抢第 i 户，抢到第 i - 1 户的最高金额|，dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])

> 时间复杂度 O(n)，空间复杂度 O(1)

<br>

### **4. 回溯算法**

> #### **题目 46：全排列**
> n 个不重复数字的全排列

- **思路**：回溯算法，回溯树深度为 n，节点数量级为 n!

- **注意事项**：
  - 递归问题的时间复杂度 = ***递归总次数 * 每次递归中的操作次数***
  - 递归问题的空间复杂度 = ***递归深度 * 每次递归的辅助空间***
  - 递归时传递的 LinkedList<Integer> track 是 ***引用***，将路径增添进 res 时，注意 new 一个 LinkedList

> 时间复杂度 O(n * n!)，空间复杂度 O(n)

<br>

> #### **题目 51：N 皇后**
> N × N 的棋盘，放置 N 个皇后，使它们不能从八个方向互相攻击

- **思路**：回溯算法，回溯树深度为 n，节点数量级为 n!

- **注意事项**：
  - 每次递归都用到数组 char[] arr，空间复杂度更大

> 时间复杂度 O(n * n!)，空间复杂度 O(n<sup>2</sup>)

<br>

### **5. BFS 算法**

> #### **题目 111：二叉树的最小高度**
> 从根节点到叶子节点的最短距离

- **思路**：**BFS 算法**，直到子节点都为 null 为止

- **注意事项**：
  - `LinkedList` 实现 `Queue` 

> 时间复杂度 O(n)，空间复杂度 O(n)<br>
> n 为节点数

<br>