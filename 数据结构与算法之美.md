# **《数据结构与算法之美》学习笔记**

## **1. 入门篇**

### **1.1. 数据结构与算法的意义**

> 我们的目的是建立时间复杂度、空间复杂度意识，写出高质量的代码，能够设计基础架构，提升编程技能，训练逻辑思维，积攒人生经验，以此获得工作回报，实现你的价值，完善你的人生。

- 优化代码及设计架构，提升代码性能（非功能性的需求）
- 看待问题的深度，解决问题的角度
- 锻炼大脑思考能力

<br>

### **1.2. 数据结构与算法的重点**

**数据结构**：一组数据的存储结构

↑↓

**算法**：操作数据的一组方法

<br>

#### **学习顺序**：
1. **复杂度分析**：衡量算法执行效率
2. **10个数据结构**：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树
3. **10个算法**：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法

#### **学习要点**：
1. 来历
2. 自身的特点
3. 适合解决的问题
4. 实际的应用场景

#### **学习技巧**：
1. 将所学的数据结构和算法自己写一遍，***适度***刷题
2. 多问、多思考、多互动
3. 设立目标，打怪升级学习法
4. ***反复迭代，不断沉淀***

<br>

### **1.3. 复杂度分析**

#### **为什么需要复杂度分析？**

分析、统计算法的执行效率和资源消耗

<del>**事后统计方法**：依赖测试环境且受数据规模影响</del>

↓

#### **大O复杂度表示法**：
渐进时间复杂度，代码执行时间（空间）随数据规模增长的变化趋势

**赋值语句**执行1次，**for循环的条件判断语句**执行n次
```
 int cal(int n) {
   int sum = 0;
   int i = 1;
   for (; i <= n; ++i) {
     sum = sum + i;
   }
   return sum;
 }
```

<br>

#### **时间复杂度量级**：

![常见复杂度量级](https://upload-images.jianshu.io/upload_images/24313937-93c53fc1e8872503.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

<br>

#### **时间复杂度类型**：

```
// 全局变量，大小为10的数组array，长度len，下标i。
int array[] = new int[10]; 
int len = 10;
int i = 0;

// 往数组中添加一个元素
void add(int element) {
   if (i >= len) { // 数组空间不够了
     // 重新申请一个2倍大小的数组空间
     int new_array[] = new int[len*2];
     // 把原来array数组中的数据依次copy到new_array
     for (int j = 0; j < len; ++j) {
       new_array[j] = array[j];
     }
     // new_array复制给array，array现在大小就是2倍len了
     array = new_array;
     len = 2 * len;
   }
   // 将element放到下标为i的位置，下标i加一
   array[i] = element;
   ++i;
}
```

***其中 len 初始值为 10 ，但随着调用函数次数 k 的增加，数组不断扩大为 10·2<sup>k</sup> ，可视为 n***

- **最好**时间复杂度  
**解**：直接插入数据的情况即 O(1)

- **最坏**时间复杂度  
**解**：数组满后复制数组的情况即 O(n)

- **平均**时间复杂度 = 加权/期望时间复杂度 = 每种情况的执行次数 * 发生概率  
**解**：n 种直接插入数据的情况， 1 种数组满后复制数组的情况，等概率为 1/(n+1)  
即 1 * 1/(n+1) + … 1 * 1/(n+1) + n * 1/(n+1) = O(1)

- **均摊**时间复杂度 = **极特殊**的平均时间复杂度  
**摊还分析法**：将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上  
**解**：前 n 次插入数据至数组（O(1)），第 n+1 次复制数组，再插入数据（O(n)），**O(1)出现的次数远大于O(n)的次数，均摊得O(1)**

<br>

## **2. 基础篇**

### **2.1. 数组：从 0 开始编号**


1. 数组寻址用到偏移量，a[0] 为偏移为 0 的首地址，a[k] 为偏移 k 个 type_size 的位置，若从 1 开始编号，a[k]的位置变为偏移 k-1，多了一次减法运算

```
a[k]_address = base_address + k * type_size
```

> 数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，**效率的优化就要尽可能做到极致**。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始

2. 历史原因，Java、JavaScript 沿用 C 语言从 0 开始计数的习惯，降低程序员学习的成本

- Matlab 数组下标从 1 开始
- Python 数组下标从 0 开始，但 -1 表示最后一行元素

<br>

#### **数据结构类型**：

![线性表数据结构](https://upload-images.jianshu.io/upload_images/24313937-415a1533379ff04b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![非线性表数据结构](https://upload-images.jianshu.io/upload_images/24313937-41430585481d5151.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

<br>

#### **数组（Array）**：
1. **线性表**数据结构
2. **连续**的内存空间
3. **相同类型**的数据

**2 + 3** → 数组支持**随机访问**，根据**下标**随机访问的时间复杂度为O(1)

<br>

#### **低效的插入与删除**：平均时间复杂度为 O(n)

- **插入操作**：**无序**情况下，插入到第 k 个位置，可把原来第 k 个位置的元素移动到数组**末尾**，如此时间复杂度为O(1)

- **删除操作**：**记录**元素已删除，当数组满后再真正执行搬移数据的操作（**批量删除**）  
**例**：JVM 标记清除垃圾回收算法，**缺点**：产生内存碎片

<br>

> 很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的**思想和处理技巧**，这些东西才是最有价值的。

<br>

#### **数组越界问题**：

```
int main(int argc, char* argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i<=3; i++){
        arr[i] = 0;
        printf("hello world\n");
    }
    return 0;
}
```

***若编译器按照内存地址递减的方式分配内存，局部变量连续压栈，arr[3] 越界访问到变量 i，将其重置为 0***

数组越界在 **C 语言** 中是一种未决行为，但 **Java** 会做越界检查

<br>

#### **容器**：封装操作细节

- C++ STL 中的vector
- Java 中的 ArrayList

**容器的优势**：
1. ArrayList封装数组操作细节
2. ArrayList支持动态扩容，**缺点**：耗时，建议指定数据大小

**数组的不可替代之处**：
1. ArrayList无法存储基本类型，需封装为类，造成性能消耗
2. 数据大小已知且操作简单的情况下，直接使用数组较为方便
3. 多维数组的定义更直观，容器套容器过于复杂，Object[][] array VS. ArrayList< ArrayList < object> > array

<br>

#### **总结 - 容器和数组**：
- **业务开发用容器**，损耗部分不影响整体
- **底层开发用数组**，优化网络框架的性能

<br>

#### **引申**：
1. `for (int i = 0; i < n; i++)` 的写法，比起 `for (int i = 0; i <= n - 1; i++)`，能够直接看出有 n - 0 = n 个数据，更为直观

2. 二维数组 a[m][n] 的内存寻址公式
```
a[i][j]_address = base_address + (i * n + j) * type_size
```

3. **JVM 标记清除算法**：运行在 JVM 上的 Java 程序，若堆内存被耗尽，则 GC 线程被触发并将程序暂停，执行标记/清除，再让程序恢复运行
- **标记**：遍历所有的 GC Roots，将所有 GC Roots **可达的对象标记为存活**
- **清除**：遍历堆中所有对象，将**没有标记的对象清除**

**缺点**：1.效率问题，标记和清除过程效率不高；2.空间问题，产生不连续的内存空间碎片

<br>

### **2.2. 链表：LRU缓存淘汰算法**

#### **缓存淘汰策略**：
- 最优替换算法 OPT（Optimal）：淘汰**未来**不常用的，***不可能实现***
- 先进先出策略 FIFO（First In，First Out）：淘汰旧的
- 最少使用策略 LFU（Least Frequently Used）：淘汰**一直**不常用的
- ***最近最少使用策略 LRU（Least Recently Used）***：淘汰**最近**不常用的

<br>

#### **链表（Linked list）**：
1. **线性表**数据结构
2. **零散**的内存块以**指针**串联
3. **相同**的数据类型

<br>

#### **链表结构类型**：
1. 单链表
2. 双向链表
3. 循环链表

<br>

- **单链表**
  - **头结点**存放链表的**基地址**，后继指针 next → 下一个结点的地址
  - **尾结点**的后继指针 next → **空地址 NULL**

![单链表](https://static001.geekbang.org/resource/image/b9/eb/b93e7ade9bb927baad1348d9a806ddeb.jpg)

<br>

#### **总结 - 数组和链表**：

1. 内存分布

![数组与链表的内存分布](https://static001.geekbang.org/resource/image/d5/cd/d5d5bee4be28326ba3c28373808a62cd.jpg)

2. 时间复杂度

|时间复杂度|数组|单链表/循环链表|双向链表|
|:-:|:-:|:-:|:-:|
|随机访问|O(1)|O(n)|O(n)|
|插入删除|O(n)|O(1)|O(1)|