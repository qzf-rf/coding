# **软件测试概念**

## **1. 软件质量模型**

- **功能性**：实现满足要求的功能
- **可靠性**：异常处理、错误恢复
- **易用性**：易懂、易学、好用、好看
- **效率性**：占用少量资源，提供适当性能
- **维护性**：修改功能方便
- **可移植**：环境迁移

<br>

## **2. 软件测试分类**

1. 按照“**是否覆盖源代码**”划分：
   - **黑盒测试**
     - 关注客户需求：输入 → 输出
   - **白盒测试**
     - 关注代码细节
   - **灰盒测试**
     - 两者之间

2. 按照“**阶段**”划分：
   - **单元测试**：类
   - **集成测试**：多个单元测试
   - **系统测试**：软件
   - **验收/交付测试**：以用户角度确认是否符合预期

3. 按照“**是否运行**”划分：
   - **静态测试**：编写、命名、注释
   - **动态测试**

4. 按照“**是否自动化**”划分：
   - **手工测试**
   - **自动化测试**：脚本

5. 更多分类：
   - **冒烟测试**：**核心功能**的质量保证
   - **回归测试**：对 BUG 或者测试用例再次测试
   - **随机测试**：跳出惯性思维，随意使用，少用
   - **探索测试**：设计测试，复杂场景，容易被忽略的场景

<br>

## **3. 软件开发常见模型**

- **瀑布模型**：阶段清晰，但依赖前面阶段，适用于需求明确的大型项目
   1. 需求分析
   2. 概要设计：框架
   3. 详细设计
   4. 编码
   5. 软件测试
   6. 软件维护

- **快速原型**：支持客户参与，但文档不完善，适用于需求灵活的中小型项目
   1. 快速分析：大致需求
   2. 构造原型
   3. 运行原型
   4. 评价原型：请客户反馈
   5. 修改意见

<br>

## **4. 软件测试常见模型**

- **V 模型**：测试介入晚，无法及早发现问题，修复成本高

```
需求分析              ←                  验收测试
    概要设计          ←              系统测试
        详细设计      ←         集成测试
            编码      ←      单元测试
```

- **W 模型**：双 V 模型，测试介入时间早，步骤复杂，对人员要求高

```
需求分析  ←  验收/系统测试设计               交付  ←   验收测试
    概要设计  ←  集成测试设计            实施  ←   系统测试
        详细设计  ←  单元测试设计     集成  ←   集成测试
            编码   ←     单元测试
```

<br>

## **5. 软件缺陷**

**定义：软件或程序中存在的各种问题及错误**
**判定标准**：
   - **违反需求**
     - **未达到需求**规格说明书标明的功能：没有实现
     - 出现需求指明不会出现的**错误**
     - **超出**需求的范围：不要猜测客户需求
   - **违反标准**
     - 未达到需求**虽未指明，但应该达到**的目标：常识标准
   - **违反易用性**
     - 软件难以理解，不易使用，运行速度慢
     

**缺陷报告的要素**
   - **缺陷 ID**：唯一标识
   - **缺陷状态**：是否修复
   - **缺陷标题**：描述
   - **严重程度**
   - **修复优先级**
   - **详细描述**：预置条件，缺陷重现步骤，实际结果，期望结果

<br>

# **黑盒测试用例**

## **1. 测试用例**

**定义**：**为了特定目的**而设计的一组 ***测试输入***、***执行条件***、***预期结果*** 的 ***输出文档***

**构成要素**：
1. **用例编号**：唯一标识，例：项目_功能_001
2. **用例标题**：测试目的（做法 + 结果）
3. **测试项目**
4. **用例级别**：根据影响范围
5. **预置条件**：数据和环境准备
6. **测试输入**
7. **执行条件**：步骤
8. **预期结果**

<br>

## **2. 黑盒测试用例设计方法**

### **2.1. 等价类**

**等价类定义**：在测试数据中，具有某种**共同特征**的**数据子集**

**有效等价类**和**无效等价类**：是否满足需求

1. 分析需求，确定**输入数据类型**
2. 使用**规则**划分有效和无效等价类
3. 设计用例，**覆盖有效等价类**（一条用例覆盖**尽可能多**的有效等价类）
4. 设计用例，**覆盖无效等价类**（一条用例覆盖**一个**无效等价类）

测试用例只需要测试**符合条件的一个随机值**

<br>

### **2.2. 边界值**

**输入范围有边界值**：**大量的错误**发生在输入或输出范围的**边界**上，而不是内部

**边界值定义**：选取**刚好等于、大于或小于边界值**作为测试数据，即**有效边界和无效边界**

- **闭区间 [0, 100]**
  - **上点**：0, 100（**有效**）
  - **离点**：-1, 101（**无效**）
  - **内点**：50

- **半开半闭区间 (0, 100]**
  - **上点**：0（**无效**）, 100（**有效**）
  - **离点**：1（**有效**）, 101（**无效**）
  - **内点**：50

- **开区间 (0, 100)**
  - **上点**：0, 100（**无效**）
  - **离点**：1, 99（**有效**）
  - **内点**：50

1. 分析需求，确定**输入数据类型**
2. 使用**规则**划分有效和无效等价类
3. ***确定上点、离点、内点***
4. 设计用例，**覆盖有效等价类**（一条用例覆盖**尽可能多**的有效等价类）
5. 设计用例，**覆盖无效等价类**（一条用例覆盖**一个**无效等价类）

<br>

### **2.3. 判定表法**

**全组合多个输入条件**：判定表列举全部**规则**

|条件桩<br>用户是否欠费|条件项<br>Y/N|
|:-:|:-:|
|**动作桩**<br>**是否允许主被叫**|**动作项**<br>**Y/N**|

1. 分析需求，定义条件桩和动作桩
2. **全组合**条件，填写条件项
3. 根据条件项，填写动作项
4. 简化判定表（**去除不存在的情况，合并相同的动作项**）
5. 抽取用例（**每个规则一条用例**）

<br>

### **2.4. 因果图法**

**基于判定表，先分析条件与条件、条件与结果之间的关系**

1. 分析需求，定义条件和动作
2. 分析条件与条件、条件与结果之间的关系
3. 通过关系画出**因果图**
4. 将因果图转换为判定表
5. 抽取用例（**每个规则一条用例**）