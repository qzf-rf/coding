# **软件测试概念**

**网站服务器**：
- **LNMP（快）**：Linux 下 Nginx, MySQL, PHP
- **LAMP（稳）**：Linux 下 Apache, MySQL, PHP

**项目管理软件**：
- 禅道

## **1. 软件质量模型**

- **功能性**：实现满足要求的功能
- **可靠性**：异常处理、错误恢复
- **易用性**：易懂、易学、好用、好看
- **效率性**：占用少量资源，提供适当性能
- **维护性**：修改功能方便
- **可移植**：环境迁移

<br>

## **2. 软件测试分类**

1. 按照“**是否覆盖源代码**”划分：
   - **黑盒测试，即功能测试（系统测试）**
     - 基于业务需求：输入 → 输出
   - **白盒测试，即结构测试（单元测试）**
     - 覆盖代码逻辑
   - **灰盒测试（集成测试）**
     - 黑盒与白盒测试交叉使用

2. 按照“**阶段**”划分：
   - **单元测试**：类
   - **集成测试**：多个单元测试
   - **系统测试**：软件
   - **验收测试**：以用户角度确认是否符合预期

3. 按照“**是否执行程序**”划分：
   - **静态测试**：编写、命名、注释
   - **动态测试**

4. 按照“**是否自动化**”划分：
   - **手工测试**
   - **自动化测试**：脚本

5. 更多分类：
   - **冒烟测试**：**核心功能**的质量保证
   - **回归测试**：对 BUG 或者测试用例再次测试
   - **随机测试**：跳出惯性思维，随意使用，少用
   - **探索测试**：设计测试，复杂场景，容易被忽略的场景

<br>

## **3. 软件开发常见模型**

- **瀑布模型**：阶段清晰，但依赖前面阶段，适用于需求明确的大型项目
   1. 需求分析
   2. 概要设计：框架
   3. 详细设计
   4. 编码
   5. 软件测试
   6. 软件维护

- **快速原型**：支持客户参与，但文档不完善，适用于需求灵活的中小型项目
   1. 快速分析：大致需求
   2. 构造原型
   3. 运行原型
   4. 评价原型：请客户反馈
   5. 修改意见

<br>

## **4. 软件测试常见模型**

- **V 模型**：测试介入晚，无法及早发现问题，修复成本高

```
需求分析              ←                  验收测试
    概要设计          ←              系统测试
        详细设计      ←         集成测试
            编码      ←      单元测试
```

- **W 模型**：双 V 模型，测试介入时间早，步骤复杂，对人员要求高

```
需求分析  ←  验收/系统测试设计               交付  ←   验收测试
    概要设计  ←  集成测试设计            实施  ←   系统测试
        详细设计  ←  单元测试设计     集成  ←   集成测试
            编码   ←     单元测试
```

<br>

## **5. 软件缺陷**

**定义：软件或程序中存在的各种问题及错误**
**判定标准**：
   - **违反需求**
     - **未达到需求**规格说明书标明的功能：没有实现
     - 出现需求指明不会出现的**错误**
     - **超出**需求的范围：不要猜测客户需求
   - **违反标准**
     - 未达到需求**虽未指明，但应该达到**的目标：常识标准
   - **违反易用性**
     - 软件难以理解，不易使用，运行速度慢

<br>

**缺陷报告的要素**
   - **缺陷 ID**：唯一标识
   - **缺陷状态**：是否修复
     - **new**：新建
     - **open**：存在
       - **reopen**：关闭的缺陷再次打开
     - **fixed**：研发称已修复
     - **closed**：回归测试证实已修复
     - **rejected**：拒绝
     - **postpone**：需要拖延
   - **缺陷标题**：描述
   - **严重程度**
     - **5-Critical**：系统瘫痪、死循环
     - **4-VeryHigh**：频繁死机
     - **3-High**：未达到需求
     - **2-Medium**：特定条件下出错
     - **1-Low**：提示出错，不影响使用
   - **修复优先级**
     - **5-Urgent**：系统不可用
     - **4-VeryHigh**：严重影响系统
     - **3-High**：影响开发测试，发布前修复
     - **2-Medium**：发布后修复
     - **1-Low**：时间资源允许再修复
   - **所属模块**
   - **详细描述**：预置条件，缺陷重现步骤，实际结果，期望结果

<br>

**缺陷产生的根源**
   - 需求变更
   - 交流不充分
   - 软件的复杂性
   - 进度压力

<br>

# **黑盒测试用例**

## **1. 测试用例**

**定义**：**为了特定目的**而设计的一组 ***测试输入***、***执行条件***、***预期结果*** 的 ***输出文档***

**构成要素**：
1. **用例编号**：唯一标识，例：项目_功能_001
2. **用例标题**：测试目的（做法 + 结果）
3. **测试项目**
4. **用例级别**：根据影响范围
5. **预置条件**：数据和环境准备
6. **测试输入**
7. **执行条件**：步骤
8. **预期结果**

<br>

## **2. 黑盒测试用例设计方法**

|测试用例方法|适用场景|
|:-:|:-:|
|**等价类法**|**单个功能**有输入，**输入无组合**|
|**边界值法**|**单个功能**有输入，**输入范围有边界**|
|**判定表法（全组合）<br>因果图法（依赖关系）**|**单个功能有多个输入输出**，输入输出、输入输入之间有**依赖关系**|
|**正交实验法**|参数配置类功能，**参数组合多**|
|**场景法（事件流）<br>状态迁移图法（状态）**|**多个功能**之间的组合逻辑测试|
|**错误推断法**|**追加易错点**的测试用例|

<br>

### **2.1. 等价类法**

**单个功能有输入，输入无组合**

**等价类定义**：在测试数据中，具有某种**共同特征**的**数据子集**

**有效等价类**和**无效等价类**：是否满足需求

1. 分析需求，确定**输入数据类型**
2. 使用**规则**划分有效和无效等价类
3. 设计用例，**覆盖有效等价类**（一条用例覆盖**尽可能多**的有效等价类）
4. 设计用例，**覆盖无效等价类**（一条用例覆盖**一个**无效等价类）

测试用例只需要测试**符合条件的一个随机值**

<br>

### **2.2. 边界值法**

**单个功能有输入，输入范围有边界值**：基于等价类法，**大量的错误**发生在输入或输出范围的**边界**上，而不是内部

**边界值定义**：选取**刚好等于、大于或小于边界值**作为测试数据，即**有效边界和无效边界**

- **闭区间 [0, 100]**
  - **上点**：0, 100（**有效**）
  - **离点**：-1, 101（**无效**）
  - **内点**：50

- **半开半闭区间 (0, 100]**
  - **上点**：0（**无效**）, 100（**有效**）
  - **离点**：1（**有效**）, 101（**无效**）
  - **内点**：50

- **开区间 (0, 100)**
  - **上点**：0, 100（**无效**）
  - **离点**：1, 99（**有效**）
  - **内点**：50

1. 分析需求，确定**输入数据类型**
2. 使用**规则**划分有效和无效等价类
3. ***确定上点、离点、内点***
4. 设计用例，**覆盖有效等价类**（一条用例覆盖**尽可能多**的有效等价类）
5. 设计用例，**覆盖无效等价类**（一条用例覆盖**一个**无效等价类）

<br>

### **2.3. 判定表法**

**单个功能有多个输入输出，输入输出、输入输入之间有依赖关系**：**全组合**，判定表列举全部**规则**

|条件桩<br>用户是否欠费|条件项<br>Y/N|
|:-:|:-:|
|**动作桩**<br>**是否允许主被叫**|**动作项**<br>**Y/N**|

1. 分析需求，定义条件桩和动作桩
2. **全组合**条件，填写条件项
3. 根据条件项，填写动作项
4. 简化判定表（**去除不存在的情况，合并相同的动作项**）
5. 抽取用例（**每个规则一条用例**）

<br>

### **2.4. 因果图法**

**单个功能有多个输入输出，输入输出、输入输入之间有依赖关系**：基于判定表法，**先分析条件与条件、条件与结果之间的关系**

1. 分析需求，定义条件和动作
2. 分析条件与条件、条件与结果之间的关系
3. 通过关系画出**因果图**（连线，线上写“或”“非”）
4. 将因果图**转换为判定表**
5. 抽取用例（**每个规则一条用例**）

<br>

### **2.5. 正交实验法**

**参数配置类功能，参数组合多**：挑选适量的、有代表性的数据，作多条件多输入的用例设计

**条件**：因子
**取值**：水平

1. 分析需求，获取因子和水平数
2. 根据因子和水平数，**查正交表**
3. 替换因子水平，**画实验表**
4. **每行一个测试用例**

<br>

### **2.6. 状态迁移图法**

**多个功能之间的组合逻辑测试**：**状态清晰**，多用于协议测试（如 TCP）

1. 分析需求，**明确状态节点**：找出所有的状态
2. 绘制**状态迁移图**：分析各个状态之间的转换条件和转换路径
3. 绘制**状态迁移树**：找到根节点，按照每条分支画，树根到树叶是一条路径
4. **抽取路径**设计用例：状态迁移路径覆盖（**每条路径一条用例**）

<br>

### **2.7. 场景法**

**多个功能之间的组合逻辑测试**：状态不清晰，但事件和流程清晰

**事件触发 → 场景
同一事件不同的触发顺序和处理结果 → 事件流**

- **基本流**：主流程，正常购物
- **备选流**：分支，取消订单
- **异常流**：分支，余额不足

1. 分析需求，**画出基本流和备选流**
2. 根据基本流和备选流生成场景：**从流程开始到流程结束为一个场景**，直到所有路径均被覆盖
3. 根据场景生成用例（**每个场景一条用例**）

<br>

### **2.8. 错误推测法**

**在易错点补充测试：经验 + 直觉，结合其他方法使用**

<br>

## **3. 白盒测试用例设计方法**

|测试用例方法|内容|
|:-:|:-:|
|***先静态测试***|***不执行**代码*|
|**桌面检查**|A 与 B **交叉解释**|
|**代码审查**|**会议上讲解代码逻辑**，与会人检查|
|**代码走查**|**会议上**与会人准备输入数据现场**演示**|
|**代码扫描工具**|**自动化匹配**|
|***后动态测试***|***执行**代码*|
|**逻辑覆盖法**<br>（重点模块）|**语句**覆盖<br>**判定**覆盖<br>**条件**覆盖<br>**判定条件**覆盖<br>**条件组合**覆盖<br>**路径**覆盖|
|**基本路径覆盖法**<br>（一般使用）|**流图的可执行路径**覆盖|

<br>

|动态测试方法|定义|
|:-:|:-:|
|**语句**覆盖法|覆盖**每个语句**|
|**判定**覆盖法|覆盖**每个判定**的真和假|
|**条件**覆盖法|覆盖**每个条件**的真和假|
|**判定条件**覆盖法|覆盖**每个判定和每个条件**的真和假|
|**条件组合**覆盖法|覆盖判定中**每个条件结果的组合**|
|**路径**覆盖法|覆盖**每个判定结果的组合**<br>覆盖面最广，但工作量太大|

<br>

> **覆盖程度**：
> 路径覆盖（不满足条件覆盖） > 条件组合覆盖 > 判定条件覆盖 > 条件覆盖（不满足判定覆盖） > 判定覆盖 > 语句覆盖

<br>

```
int logicExample(int x, int y, int magic) {
  // 判定 P1，条件 C1 && 条件 C2
  if (x > 0 && y > 0) {
    A = x + y + 10; // 语句块 1
  }
  else {
    A = x + y - 10; // 语句块 2
  }

  // 判定 P2，条件 C3
  if (magic < 0) {
    A = 0; // 语句块 3
  }
  return A; // 语句块 4
}
```

<br>

### **3.1. 逻辑覆盖法**

**遍历程序逻辑结构**

**覆盖率**：度量测试完整性

> **覆盖率 = 至少被执行一次的 item 数 / item 的总数**
**item**：语句、判定、条件、判定条件、条件组合、路径

<br>

#### **3.1.1. 语句覆盖法**

设计测试用例，使**程序中每条语句至少被执行一次**

> **语句覆盖率 = 至少被执行一次的语句数量 / 可执行的语句总数**

1. 设计**输入数据，100% 语句覆盖**

|输入数据|覆盖语句|
|:-:|:-:|
|{x = 3, y = 1, magic = 2}|1, 4|
|{x = -3, y = -1, magic = -2}|2, 3, 4|

**局限性**：语句覆盖标准最弱，不能准确判断运算中的逻辑关系错误
例： `if (x > 0 && y > 0)` 写成 `if (x > 0 || y > 0`

<br>

#### **3.1.2. 判定覆盖法**

设计测试用例，使程序中每个判断的“真”或“假”都至少被执行一次，即**程序中的每个分支至少执行一次**

> **判定覆盖率 = 每个判定的真和假值至少出现一次 / 判定结果的总数**

1. 设计**输入数据，100% 判定覆盖**

|输入数据|判定 P1|判定 P2|
|:-:|:-:|:-:|
|{x = 3, y = 1, magic = 2}|T|F|
|{x = -3, y = -1, magic = -2}|F|T|

**局限性**：判定覆盖与语句覆盖一样会忽略条件中**取 `||` 的情况**

<br>

#### **3.1.3. 条件覆盖法**

设计测试用例，使**判定中的每个条件至少有一次取真值，有一次取假值**

> **条件覆盖率 = 每个条件的真和假值至少出现一次 / 条件结果的总数**

1. 设计**输入数据，100% 条件覆盖**

|输入数据|条件 C1|条件 C2|条件 C3|判定 P1|判定 P2|
|:-:|:-:|:-:|:-:|:-:|:-:|
|{x = 3, y = 0, magic = -2}|T|F|T|F|T|
|{x = -3, y = 1, magic = 2}|F|T|F|F|F|

**局限性**：条件覆盖不能保证判定覆盖

<br>

#### **3.1.4. 判定条件覆盖法**

设计测试用例，使程序中每个判定的判定结果（真和假）至少满足一次，同时，每个条件的可能值（真和假）也至少被满足一次，即**同时满足 100% 判定覆盖和 100% 条件覆盖**

1. 设计**输入数据，100% 判定条件覆盖**

|输入数据|条件 C1|条件 C2|条件 C3|判定 P1|判定 P2|
|:-:|:-:|:-:|:-:|:-:|:-:|
|{x = 3, y = 3, magic = 2}|T|T|F|T|F|
|{x = -3, y = 0, magic = -2}|F|F|T|F|T|

**局限性**：判定条件覆盖同样会忽略条件中**取 `||` 的情况**

<br>

#### **3.1.5. 条件组合覆盖法**

设计测试用例，使程序中的**每个判定中条件结果的所有可能组合**都至少执行一次（如：真真、假假、真假、假真）

> **条件组合覆盖率 = 条件组合至少出现一次的数量 / 条件组合的总数**

1. 设计**输入数据，100% 条件组合覆盖**

|输入数据|条件 C1|条件 C2|条件 C3|判定 P1|判定 P2|
|:-:|:-:|:-:|:-:|:-:|:-:|
|{x = 3, y = 3, magic = 2}|**T**|**T**|**F**|T|F|
|{x = -3, y = 10, magic = -2}|**F**|**T**|**T**|F|T|
|{x = 3, y = 0, magic = -2}|**T**|**F**|**T**|F|T|
|{x = -3, y = -5, magic = 2}|**F**|**F**|**F**|F|F|

**局限性**：条件组合覆盖不能保证**所有路径**被执行（包含单个判定中的条件组合，但不包含所有的判定结果组合）

<br>

#### **3.1.6. 路径覆盖法**

设计测试用例，覆盖程序中**所有可能的路径**（所有的判定结果组合）

> **路径覆盖率 = 至少被执行过一次的路径数 / 总的路径数**

1. 设计**输入数据，100% 路径覆盖**

|输入数据|条件 C1|条件 C2|条件 C3|判定 P1|判定 P2|
|:-:|:-:|:-:|:-:|:-:|:-:|
|{x = 3, y = 3, magic = 2}|T|T|F|**T**|**F**|
|{x = -3, y = 10, magic = -2}|F|T|T|**F**|**T**|
|{x = 3, y = 3, magic = -2}|T|T|T|**T**|**T**|
|{x = -3, y = 5, magic = -2}|F|T|F|**F**|**F**|

**局限性**：路径覆盖**不能满足条件覆盖**

<br>

#### **3.2. 基本路径测试法**

在**程序控制流图**的基础上，通过分析程序的环路复杂性，导出**基本可执行路径集合**，从而设计测试用例

1. 根据代码画出程序控制流图（流程图节点改为**小圆圈**，里面写着**代码行数**）
2. 计算程序的**环路复杂度**
   - 流图中**区域的数量**对应环形的复杂性
   - 给定流图 G 的圈复杂度 V(G)，定义为 V(G) = E - N + 2，E 是流图中边的数量，N 是流图中节点的数量
   - 给定流图 G 的圈复杂度 V(G)，定义为 V(G) = P + 1，P 是流图中判定节点的数量
3. **导出 V(G) 条可执行路径**：每条边都覆盖一次
4. 设计测试用例：设计输入数据，计算预期结果